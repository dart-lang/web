import 'dart:js_interop';
import '../../ast.dart';
import '../../ast_extensions.dart';
import '../../js/typescript.dart' as ts;
import '../../js/typescript.types.dart';
import '../namer.dart';
import '../transform.dart';

class Transformer {
  /// A map of already resolved TS Nodes
  final List<TSNode> nodes = [];

  /// A map of declarations
  final DeclarationMap declarationMap = DeclarationMap(<String, Node>{});

  /// The type checker for the given program
  final ts.TSTypeChecker typeChecker;

  /// A set of declarations to export
  final Set<String> exportSet;

  /// namer, for giving elements unique names
  final UniqueNamer namer;

  final ProgramDeclarationMap programMap;

  Transformer(this.programMap, this.typeChecker,
      {Iterable<String> exportSet = const []})
      : exportSet = exportSet.toSet(),
        namer = UniqueNamer();

  void transform(TSNode node) {
    if (nodes.contains(node)) return;

    switch (node.kind) {
      case TSSyntaxKind.VariableStatement:
        final decs = _transformVariable(node as TSVariableStatement);
        declarationMap.addAll({ for (final d in decs) d.id: d });
      default:
        final Declaration decl = switch (node.kind) {
          _ => throw Exception('Unsupported Declaration Kind: ${node.kind}')
        };
        // ignore: dead_code This line will not be dead in future decl additions
        declarationMap[decl.id] = decl;
    }
    
    nodes.add(node);
  }

  DeclarationMap filter([bool Function(Node)? saveIf]) {
    // Set<String> dependencies = {};
    final filteredDeclarations = DeclarationMap({});

    // filter out for export declarations
    declarationMap.forEach((k, v) {
      // get decls exported by name
      if (exportSet.contains(v.name)) {
        filteredDeclarations[k] = v;
      }

      // get decls with `export` keyword
      switch (v) {
        case final ExportableDeclaration e:
          if (e.exported) {
            filteredDeclarations[(e as Node).id] = e as Node;
          }
          break;
        case final PrimitiveType _:
          // primitive types are generated by default
          break;
        case Type():
          // TODO: Handle this case.
          throw UnimplementedError();
        case Declaration():
          // TODO: Handle this case.
          throw UnimplementedError();
      }
    });

    filteredDeclarations.removeWhere((k, v) => !(saveIf?.call(v) ?? true));

    // then filter for dependencies
    final otherDecls = filteredDeclarations.entries
        .map((e) => _filterForDecl(e.value))
        .reduce((value, element) => value..addAll(element));

    return filteredDeclarations..addAll(otherDecls);
  }

  /// Given an already filtered declaration [decl],
  /// filter out dependencies of [decl] and return them as a declaration map
  DeclarationMap _filterForDecl([Node? decl]) {
    final filteredDeclarations = DeclarationMap({});

    switch (decl) {
      case final VariableDeclaration v:
        if (v.type is! PrimitiveType) filteredDeclarations.add(v.type);
        break;
      case final UnionType u:
        filteredDeclarations.addAll({for (final t in u.types.where((t) => t is! PrimitiveType)) t.id: t});
        break;
      case final PrimitiveType _:
        // primitive types are generated by default
        break;
      default:
        print('WARN: The given node type ${decl.runtimeType.toString()} '
            'is not supported for filtering. Skipping...');
        break;
    }

    if (filteredDeclarations.isNotEmpty) {
      final otherDecls = filteredDeclarations.entries
          .map((e) => _filterForDecl(e.value))
          .reduce((value, element) => value..addAll(element));

      filteredDeclarations.addAll(otherDecls);
    }

    return filteredDeclarations;
  }

  List<Declaration> _transformVariable(TSVariableStatement variable) {
    // get the modifier of the declaration
    final modifiers = variable.modifiers.toDart;
    final isExported = modifiers.any((m) {
      return m.kind == TSSyntaxKind.ExportKeyword;
    });

    var modifier = VariableModifier.$var;

    if ((variable.flags & TSNodeFlags.Const) != 0) {
      modifier = VariableModifier.$const;
    } else if ((variable.flags & TSNodeFlags.Let) != 0) {
      modifier = VariableModifier.let;
    }

    return variable.declarationList.declarations.toDart.map((d) {
      namer.markUsed(d.name.text);
      return VariableDeclaration(
          name: d.name.text,
          type: d.type == null ? PrimitiveType.any : _transformType(d.type!),
          modifier: modifier,
          exported: isExported);
    }).toList();
  }

  TSNode? _getDeclarationByName(TSIdentifier name) {
    final symbol = typeChecker.getSymbolAtLocation(name);

    final declarations = symbol?.getDeclarations();
    // TODO(https://github.com/dart-lang/web/issues/387): Some declarations may not be defined on file,
    //  and may be from an import statement
    //  We should be able to handle these
    return declarations?.toDart.first;
  }

  /// Parses the type
  ///
  /// TODO(https://github.com/dart-lang/web/issues/384): Add support for literals (i.e individual booleans and `null`)
  /// TODO(https://github.com/dart-lang/web/issues/383): Add support for `typeof` types
  Type _transformType(TSTypeNode type) {
    if (type.kind == TSSyntaxKind.UnionType) {
      final unionType = type as TSUnionTypeNode;
      // parse union type
      return UnionType(
          types: unionType.types.toDart.map<Type>(_transformType).toList());
    }

    if (type.kind == TSSyntaxKind.TypeReference) {
      // reference type
      final refType = type as TSTypeReferenceNode;

      final name = refType.typeName.text;
      final typeArguments = refType.typeArguments?.toDart;

      var declarationsMatching = declarationMap.findByName(name);
      if (declarationsMatching.isEmpty) {
        // TODO: In the case of overloading, should/shouldn't we handle more than one declaration?
        final declaration = _getDeclarationByName(refType.typeName);

        if (declaration == null) {
          throw Exception('Found no declaration matching $name');
        }

        transform(declaration);

        declarationsMatching = declarationMap.findByName(name);
      }

      // TODO: In the case of overloading, should/shouldn't we handle more than one declaration?
      final firstNode = declarationsMatching.whereType<NamedDeclaration>().first;

      return firstNode.asReferredTypeWithTypeArgs(
        (typeArguments ?? []).map(_transformType).toList(),
      );
    }

    // check for its kind
    return switch (type.kind) {
      TSSyntaxKind.StringKeyword => PrimitiveType.string,
      TSSyntaxKind.AnyKeyword => PrimitiveType.any,
      TSSyntaxKind.ObjectKeyword => PrimitiveType.object,
      TSSyntaxKind.NumberKeyword => PrimitiveType.number,
      TSSyntaxKind.UndefinedKeyword => PrimitiveType.undefined,
      TSSyntaxKind.UnknownKeyword => PrimitiveType.unknown,
      TSSyntaxKind.BooleanKeyword => PrimitiveType.boolean,
      _ => throw UnsupportedError(
          'The given type with kind ${type.kind} is not supported yet')
    };
  }
}
